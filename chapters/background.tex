
\paragraph{} This chapter will cover a number of topics essential to understanding the rationale and implementation of the design as discussed in §~\ref{sec:design}. These include; an introduction to \textit{Information Flow Control} (\textit{IFC}), the Intel SGX platform, and an overview of key aspects of the Linux kernel relevant to the architecture of the prototype.


% -------------

\section{Information Flow Control}
\label{sec:ifc}

\paragraph{} IFC regulates how and where data is permitted to move and be transformed in a computer system.~\cite{ifc-data-prop} This differs from access control, which defines \textit{what} resources may be used by an entity --- IFC allows granular control over \textit{how} they may be used once accessed, including restricting propagation between components. 

\paragraph{} Formally, IFC defines and enforces a non-interference policy between abstract \textit{security contexts}. A simple, atomic example is the distinction between \textit{unclassified} and \textit{classified} data --- here, information is only allowed to flow \textit{up}, ensuring that an \textit{unclassified} entity does not learn anything marked as \textit{classified}.~\cite{Bell1973SecureCS} In general this form of relationship can be represented as a partial ordering over \textit{security contexts}, formulated as a lattice.~\cite{ifc-lattice}

\paragraph{} However, practical systems often require dataflow adhering to a more complicated policy set --- for example, supporting \textit{declassification}.~\cite{10.5555/794199.795122} Work undertaken by Pasquier et al.,~\cite{camflow} which will be the core influence of the IFC model developed in this project, constructs a pliable and efficient \textit{decentralised information flow control} (\textit{DIFC}) model suitable for provenance enforcement and auditing in the Linux kernel.

\paragraph{} The concepts presented are primarily derived from Pasquier~\cite{camflow} and Krohn et al.~\cite{flume}.

\subsection{Motivation, History, and \textit{Decentralised IFC}}

\paragraph{} IFC has, in recent years, been increasing in support as a powerful methodology for ensuring granularly privacy whilst simultaneously not unduly restricting access to sensitive information. IFC annotates data records with opaque \textit{labels} that refer to either their confidentiality or integrity status. Rather than simply restricting access to sensitive data, as would be the action taken by an access control mechanism, IFC opts to track data as it propagates --- if an entity attempts to move this into an unknown, untrusted, or conflicting \textit{security context} the IFC system prevents this to ensure data is not improperly released.

\paragraph{} IFC originated from research conducted in the mid-1970s~\cite{ifc-lattice} but has not, as of yet, seen mainstream adoption. A major reason for this is that early schemes were designed around the \textit{multi-level security} (\textit{MLS}) doctrine set out in the \textit{Orange Book}:~\cite{orange-book} this locked IFC to a shallow set of broad labels, mirroring existing institutional segregation (such as \textit{restricted}, \textit{secret}, \textit{top secret}). Policies were managed centrally, something easily applicable in settings with rigorous hierarchies such as the military, but unwieldy in an organisation with manifold security protocols.

\paragraph{} The majority of recent research in this area has advocated \textit{decentralised information flow control} 
(\textit{DIFC}), introduced by Myers and Liskov.~\cite{difc,10.1145/363516.363526,10.1145/268998.266669} DIFC is more granular that schemes adhering to the \textit{MLS} model, for example, creating two distinct \textit{security contexts} for two files in the same folder. Policies are \textit{discretionary}, allowing users to specify and modify the enforced policies for assets they own.

\subsection{Security Labels and the Reference Monitor}

\paragraph{} A DIFC system relies on \textit{tags} and \textit{labels} to annotate the entities it tracks. Let $\mathcal{T}$ be a large set of opaque tokens, or \textit{tags}. An individual tag does not carry any particular meaning by itself, but is used as an abstract identifier for the integrity or secrecy of an entity's \textit{security context}. A \textit{label}, $l \subseteq \mathcal{T}$, is a collection of tags that are concretely attached to assets, such as files; these form a lattice under the subset-relation partial order. For each process $a$ there are two labels, one for secrecy, $a_s$, and one for integrity, $a_i$. For a tag $t$, $t \in a_s$ implies, conservatively, that process $a$ has seen information associated with tag $t$. Likewise, $t \in a_i$ indicates that every input to $a$ has been endorsed for an integrity level marked with $t$.

\paragraph{Walkthrough --- Secrecy Enforcement} In a typical environment, a user can only convince themselves that a text editor is safe to use it they, or someone they trust, audits the program's source code. With DIFC however, it is possible to reason that if the system can provide the following four guarantees, it cannot leak sensitive data without the user's permission.

\begin{enumerate}
    \item If a process $a$ read a file with a secrecy tag $t$, then $t \in a_s$.
    \item $t \in a_s$ implies that $a$ cannot communicate with another process, $b$, where $t \notin b_s$.
    \item $a$ cannot remove $t$ from $a_s$ without permission.
    \item $t \in a_s$ restricts $a$'s access to an uncontrolled medium, such as a network.
\end{enumerate}

\paragraph{} The heart of an IFC implementation is its \textit{Reference Monitor}, which tracks the labelling for each process, granting or rejecting permission to execute an operation before being served to the operating system. Different solutions handle this process differently: \textit{Flume},~\cite{flume} for example, implements a full system interposition layer, forcing all \textit{syscalls} to pass through its userspace \textit{reference monitor} before reaching the OS, whereas \textit{CamFlow}~\cite{camflow} embeds its \textit{reference monitor} in the kernel itself. In all schemes, however, this trusted component is responsible for the policy and its enforcement on the system. This project focusses on this implementation.


\subsection{Modelling}
\label{sec:ifc-modelling}

\begin{table}
    \centering
    \newcommand\tableTop{\rule{0pt}{3ex}}
    \newcommand\tableMid{\rule{0pt}{3ex}}
    \newcommand\tableBottom{\rule[-2ex]{0pt}{0pt}}
    \begin{tabular}{r p{10cm}} 
        \hline
        Notation & Explanation \\ [0.1ex] 
        \hline
            \tableTop{$A \rightarrow B$} & \tableTop{Rule $\alpha$; a permissible information flow between entity $A$ and entity $B$.} \\
            
            $A \Rightarrow B$ & \tableMid{Rule $\beta$; a creation flow, initialising $B$ from $A$ as its parent.} \\

            $A \rightsquigarrow A'$ & \tableMid{Rule $\gamma$; a context change, with $A$ modifying its security context in accordance with its capabilities.} \\
            
            $A \xhookrightarrow[]{t^{\pm}_{x}} B$ & \tableMid{Rule $\delta$; priviledge delegation, with $A$ passing a capability $t_{x}^{\pm}$ to $B$.} \tableBottom \\
    \end{tabular}
    % \vspace{5mm}
    \caption{Overview of the four core IFC events used in §~\ref{sec:ifc-modelling}.}
    \label{table:ifc-notation}
\end{table}


\paragraph{} In centralised IFC schemes, the reference monitor is the only entity capable of creating, changing, and assigning tags. DIFC modifies this, giving \textit{all} processes the ability to create and modify tags for entities they hold ownership over; thus they alone have the right to declassify them.

\paragraph{Notation} As the model we build in §~\ref{sec:design} is closest in spirit to \textit{CamFlow}, we, for clarity in comparison, use the same notation (as summarised in Table~\ref{table:ifc-notation}).

\paragraph{Enforcing Safe Flows} ($\alpha$), below, describes the conditions in which a flow can be considered \textit{safe}, abiding by the system's IFC policy. Verbally, the recipient must be \textit{at least as privileged} as the originator and cannot accept information graded below its own integrity status. Here $\preceq$ denote any applicable preorder relation; this context uses inclusion ($\subseteq$). If a flow is \textit{impermissible} it is denoted as $A \nrightarrow B$.
\begin{equation}
    A \rightarrow B \iff A_s \preceq B_s \;\; \land \;\; B_i \preceq A_i \tag{$\alpha$}
\end{equation}
\paragraph{} Information produced within a \textit{security context} may only flow within the same context or a related \textit{subcontext}. Integrity functions in the same way but in the inverse; data can only flow in contexts with the same, or lower, integrity grading.

\paragraph{Entity Creation} Correct initialisation of a new object's \textit{security context} is shown in ($\beta$). Logically it must be held at the same level as the environment creating it. An illustrative example is a process creating a new file; although permitted the result is subject to the same tainting as the original process.
\begin{equation}
    A \Rightarrow B \implies A_s = B_s \;\; \land \;\; A_i = B_i \tag{$\beta$}
\end{equation}

\paragraph{Vocational Label Management} The core mantra of the \textit{decentralised} aspect of \textit{DIFC} is that processes are themselves responsible for policies governing the assets they own. To this end, a process's labelling must be dynamic. Generally, entities can be sorted into two distinct categories;

\begin{itemize}
    \item \textit{Active} (processes), with \textit{mutable} security contexts.
    \item \textit{Passive} (files, pipes, sockets, etc.), which merely act as data vessels for \textit{active} entities.
\end{itemize}

\paragraph{} \textit{Active} entities have the right to modify their labelling iff they have the capability to make that modification. These capabilities come in two forms; one for addition and one for removal of tags. The set $A_{s}^{+} \subseteq \mathcal{T}$ enumerates all the tags that entity $A$ has the ability to add to its security labelling. Likewise, $A_{s}^{-} \subseteq \mathcal{T}$ holds all of the tags $A$ has the ability to remove from its labelling. These sets are modified either in the process of creating an entity or in receipt of a delegated capability from a peer. The sets $A_{i}^{\pm} \subseteq \mathcal{T}$ also exist, performing the same function for integrity labels. ($\gamma$) describes this process formally.
\begin{equation}
    \left\{\begin{array}{lr}
        A'_x \leftarrow A_x \cup \{t\} & \text{if} \;\; t \in A_{x}^{+} \\
        A'_x \leftarrow A_x \smallsetminus \{t\} & \text{if} \;\; t \in A_{x}^{-} \\
    \end{array}\right\} \implies A \rightsquigarrow A' \tag{$\gamma$}
\end{equation}

\paragraph{} A notable restriction is that a process has to be aware of the IFC constraints imposed on it and how to interact with the system to perform this operation. Most processes should not require this, but is an important consideration when applying DIFC to an entire system.

\paragraph{Capability Lifecycle and Delegation} As defined by ($\beta$), an entity automatically inherits the labelling of its creator: this process, however, does not pass on any capabilities ($A_{s}^{\pm}, A_{i}^{\pm} = \varnothing$). This raises the need for \textit{capability delegation}.

\paragraph{} A capability held by $A$, $t_{x}^{\pm}$, where $t \in A_{x}^{\pm}$, is permitted to be transferred to $B$ in order for it to act on its behalf. Delegation is denoted as follows in ($\delta$).


\begin{equation}
    A \xhookrightarrow[]{t^{\pm}_{x}} B \;\; \text{only if} \;\; t \in A_{x}^{\pm} \tag{$\delta$}
\end{equation}

\paragraph{} As an example, delegation is vital for a web server. To transmit another entity's information over an untrusted socket the server must have permission to \textit{declassify} it --- i.e. it must hold $f_{s}^{-}$, where $f$ is the secrecy label of the information to transmit.\footnote{The server process, $W$, must have $W_{i} = \varnothing$ as it holds a connection to an untrusted socket. Thus the integrity clause in ($\alpha$) will not interfere.}


% ---------

\section{Intel® SGX}

\paragraph{} Intel's Software Guard Extensions, SGX, was first announced and detailed in a handful of whitepaper documents published from 2013.~\cite{10.1145/2487726.2488370, 10.1145/2487726.2488368, Anati2013InnovativeTF, sgx-sgx-reference} It described a novel approach to \textit{trusted computing}, creating in-CPU containers with dedicated protected memory pools. These regions, called \textit{enclaves}, cannot be read from or written to by an unauthorised party due to fundamental protection mechanisms provided by the x86 architecture, even if running in \textit{Ring 0}:\footnote{x86 offers four protection \textit{rings}, of which Linux uses two --- \textit{0} for the kernel, and \textit{3} for userspace.} Figure~\ref{fig:sgx-basic} illustrates this. \textit{Enclaves} guarantee both integrity and secrecy to the application running inside it, even in the presence of a malicious host.

\paragraph{Motivation} At a high-level SGX aims to achieve security for sensitive applications by shielding them, and the resources they use, against tampering, and to provide a guarantee to end-users of an enclave's integrity; this is achieved using attestation and measurement (described in §~\ref{sec:attestation}). One of many use cases~\cite{10.1145/2834050.2834100, 10.1145/2799647, 10.1145/2810103.2813695} is in a cloud computing context, where users are forced to trust an outside party with both their data and business logic. By distributing encrypted, yet executable, containers targetted at a single, unique SGX core, users can be assured that their information is safe, regardless of any virtualisation that may be taking place. Only the provisioned CPU is able to decrypt and execute the enclave, strictly in accordance with the restrictions of the SGX platform.

\subsection{Security Characteristics}

\begin{figure}[]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/SGX-architecture.pdf}
    \caption{Abstract overview of SGX's protection in an adversarial environment.}
    \label{fig:sgx-basic}
\end{figure}

\paragraph{} At its heart SGX is designed to be \textit{trustworthy}; this is achieved in a number of ways, including robust enclaving provisioning, sealing and attestation. Intel enumerates SGX's protections~\cite{10.1145/2487726.2488368,sgx-eval-sdk} as follows;

\begin{itemize}
    \item Memory is secured against observation and modification from outside the enclave, achieved using an in-die \textit{Memory Encryption Engine} (\textit{MEE}),~\cite{sgx-mee} with a secret that rotates on every boot. This protection notably works against host hypervisors, other enclaves, and anything running in supervisor mode.
    \item Enclaves can \textit{attest to}, or prove, their identity to a challenger with the help of a permanent hardware security key for asymmetric encryption.
    \item Software calls are proxied to prepare and transfer control in and out of an enclave. Arguments are securely marshalled according to a static enclave definition.
    \item SGX does not defend against reverse engineering or side-channel attacks:~\cite{10.1109/SP.2015.45} this is the responsibility of the developer to mitigate.
    \item Debugging support is only provided via a specialised tool and only when an enclave is compiled with debugging enabled.
\end{itemize}

\subsection{Architecture and Implementation}

\begin{figure}[]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/SGX-AdvArchitecture.pdf}
    \caption{A high-level overview of the SGX hardware and software architecture.}
    \label{fig:sgx-advarch}
\end{figure}

\paragraph{} The SGX platform comprises a number of interlocking parts, as shown in Figure~\ref{fig:sgx-advarch}. Working from the hardware up, at the heart of the platform is the extended x86 instruction set and memory protection provided by an SGX-capable CPU. Information as reported by~\cite{sgx-sgx-reference,Costan2016IntelSE}.

\paragraph{Hardware} Enclaves' data and code is stored securely in \textit{Processor Reserved Memory}, \textit{PRM}; this is a set of pages in system memory that are presided over by the \textit{MEE}. DMA\footnote{Direct Memory Access} to \textit{PRM} is always rejected. \textit{PRM} consists of two data structures; the \textit{Enclave Page Cache Map} (\textit{EPCM}) and the \textit{Enclave Page Cache} (\textit{EPC}). An individual enclave is defined by an \textit{SGX Enclave Control Structure}, \textit{SECS}; this is generated when an enclave is created and stored in a dedicated entry in the \textit{EPC}. An enclave's \textit{SECS} contains important information such as its (system) global identifier, its measurement hash (\texttt{MRENCLAVE}, §~\ref{sec:attestation}) and the amount of memory it is using. Access control information is stored in the \textit{EPCM} alongside page validity flags, the owning enclave identifier and the page's type; this is not accessible in software. An attempt to resolve a page in \textit{PRM} is successful only if the CPU is executing in enclave mode and its \textit{EPCM} entry states it belongs the currently executing enclave --- if this is not the case the lookup returns an unused page from generic system memory.

\paragraph{} The host OS or hypervisor manages the \textit{EPC} just as it does with standard system memory, swapping pages in and out according to its own policy, but must do so using SGX specific instructions. The \textit{MEE} is responsible for ensuring the integrity and confidentiality of this process, encrypting and decrypting pages as they cross the \textit{PRM} boundary. Data is verified with the use of an integrity tree, and encryption keys are generated at boot-time. Importantly the SGX architecture relies on the host OS being SGX-aware, empowering userspace applications to function without privilege; this is provided by the SGX driver, \textit{isgx}.

\paragraph{Userspace services} Starting an enclave requires a \textit{launch token} to be reteived from Intel's \textit{Launch Enclave}; this checks the signature and identity of the enclave to ensure it is valid. Access to the \textit{Launch Enclave} and other architectural enclaves is provided by the AESM service; the userspace SGX libraries facilitate the communication mechanism. Other architectural enclaves include;

\begin{itemize}
    \item The \textit{Provisioning Enclave} --- this verifies the authenticity of the platform and retrieves an enclave's \textit{attestation key} from the \textit{Intel Provisioning Service's} servers.
    \item The \textit{Quoting Enclave} --- this provides trust in the identity of the SGX environment and enclave being attested, by converting the locally generated \textit{attestation key} to a remotely-verifiable \textit{quote}.
\end{itemize}

\paragraph{Third-party enclaves} Enclaves can only be entered via userspace, as detailed in §~\ref{sec:sgx-lifecycle}, and are always accompanied by a host application which acts as its untrusted counterpart. The host application calls the SGX SDK to build an enclave on its behalf using an enclave image, packaged as a standard shared library (\texttt{enclave.so}) and returns its \textit{global identifier}. Control is passed from the host application to the enclave by invoking an enclave function via an \textit{ECALL}. Execution flow can temporarily leave the enclave if it calls one of the host application's functions via an \textit{OCALL}. Execution naturally leaves enclave-mode when an \textit{ECALL} terminates. Both \textit{ECALLs} and \textit{OCALLs} are defined statically in the enclave's interface definition (\texttt{enclave.edl}), and the necessary glue code is generated by the SGX SDK's build toolchain at compile time; this ensures calls crossing the enclave boundary are marshalled safely and correctly.


\subsection{Enclave Lifecycle}
\label{sec:sgx-lifecycle}

\paragraph{} SGX instructions can be separated into two distinct groups; privileged and unprivileged. These, alongside a description of the function they perform, are enumerated in Table~\ref{table:sgx-instructions}.\footnote{A handful of instructions not relevant to the explanation given here are omitted.} The following description of the process of creating an enclave is illustrated in Figure~\ref{fig:sgx-enclavecreate}.

\paragraph{Preparing an enclave} Execution begins with the host application; is needs to initiate the creation process, but must do so via a component with \textit{Ring 0} privilege. This facility is provided by \textit{isgx}, the SGX driver. The application first requests \textit{isgx} to allocate the requisite number of pages to run the enclave $\langle 1 \rangle$;\footnote{These numbers correspond to events in Figure~\ref{fig:sgx-enclavecreate}.} this is tracked and served from the driver's internal state $\langle 2 \rangle$.

\paragraph{} The application continues by executing \texttt{ECREATE} with the metadata of the enclave to be loaded $\langle 3 \rangle$; the \textit{MEE} checks that the pages being claimed are in fact vacant and populates the \textit{SECS} page with the necessary information $\langle 4 \rangle$. Once this is complete the application prepares the remaining \textit{EPC} pages using \texttt{EADD} $\langle 5 \rangle$ and loads the enclave's code and data $\langle 6 \rangle$.

\paragraph{} At this point the enclave needs to be measured --- the application calls \texttt{EEXTEND} $\langle 7 \rangle$, triggering the \textit{MEE} to update the measurement hash in the \textit{SECS} to aligns with the current state of the enclave's memory $\langle 8 \rangle$. Once the \textit{EPC} memory is prepared the application requests for it to be finalised using \texttt{EINIT} $\langle 9 \rangle$: this operation requires the application to retrieve the \texttt{EINITTOKEN} from the \textit{Launch Enclave}, locking the execution of the measured enclave to the CPU the token is generated on. Notably, pages cannot be added after \texttt{EINIT},\footnote{This is only strictly true in SGXv1, as explained in §~\ref{sec:sgx-versions}.} and an enclave cannot be attested to or entered before it. Finally, the initialised flag is set in the \textit{SECS} and the enclave's hash updated for the final time $\langle 10 \rangle$.


\begin{figure}[]
    \centering
    \includegraphics[width=\linewidth]{figures/SGX-EnclaveCreate.pdf}
    \captionsetup{justification=centering}
    \caption[The process of creating and initialising an enclave.]{The process of creating and initialising an enclave; details given in §~\ref{sec:sgx-lifecycle}. Purple components belong to the SGX platform.}
    \label{fig:sgx-enclavecreate}
\end{figure}

\paragraph{Stepping into the enclave} Once an enclave is created it can be invoked using the \texttt{EENTER} instruction; this can only jump to code explicitly defined in the enclave's interface definition and switches the CPU core to enclave mode. SGX uses a flag in the CPU core's \textit{Thread Control Block} to prevent any other logical core following the current one into the enclave.

\paragraph{} Interrupts and exceptions can be served to the enclave, just as with any other application. However, control is not immediately passed over to the defined handler. Instead, the enclave's current state is saved and cleared to ensure no data is leaked. The \textit{Asynchronous Enclave Exit} routine is then invoked and enclave mode disabled. Execution post-interruption is restarted with the \texttt{ERESUME} instruction. Once an enclave has finished executing the registers are erased and \texttt{EEXIT} called. Enclaves are terminated using the \texttt{EREMOVE} command; all claimed \textit{EPC} pages are marked as invalid and the \textit{SECS} page deleted.

\paragraph{} \label{sec:sgx-no-kernel-mode} A significant design decision made in the SGX architecture is that enclaves cannot be entered by a process operating in \textit{Ring 0};~\cite{sgx-prog-reference} the required instructions simply aren't available. This forces all host applications to run in userspace, making interoperation with the kernel challenging, as will be discussed in §~\ref{sec:design}.

\begin{table}
    \centering
    \newcommand\tableTop{\rule{0pt}{3ex}}
    \newcommand\tableMid{\rule{0pt}{3ex}}
    \newcommand\tableBottom{\rule[-2ex]{0pt}{0pt}}
    \begin{tabular}{|c|r|p{8.5cm}|} 
        \hline
        Execution Mode & Instruction & Function \\ [0.1ex] 
        \hline\hline
        \multirow{11}{*}{Ring 0} 
            & \tableTop{\texttt{ECREATE}} & \tableTop{Generate and copy the \textit{SECS} structure to a new page in the \textit{EPC}, initialising a new enclave.} \\ 
            & \texttt{EADD} & \tableMid{Add a new \textit{EPC} page for the current enclave; this is used to load initial code and data.} \\ 
            & \texttt{EEXTEND} & \tableMid{Updates the enclave's measurement during attestation; modifies the \textit{SECS}.} \\ 
            & \texttt{EINIT} & \tableMid{The terminal instruction in an enclave's initialisation, finalising its attributes and measurement.} \\ 
            & \texttt{EREMOVE} & \tableMid{Permanently remove a page from the \textit{EPC}; usually invoked during enclave destruction.} \tableBottom \\ 
        \hline\hline
        \multirow{11}{*}{Ring 3} 
        & \tableTop{\texttt{EENTER}} & \tableTop{Transfer control from the host application to a pre-determined location in an enclave.} \\ 
        & \texttt{ERESUME} & \tableMid{Re-enter the enclave after an interrupt/exception and resume execution.} \\ 
        & \texttt{EEXIT} & \tableMid{Restore the original operating mode at the location \texttt{EENTER} was triggered and flush the TLB.} \\ 
        & \texttt{EGETKEY} & \tableMid{Access platform cryptography keys required for attestation and sealing.} \\ 
        & \texttt{EREPORT} & \tableMid{Generate a \textit{report} for an enclave's \textit{attestation key} for an attestation process.} \tableBottom \\ 
        \hline
    \end{tabular}
    \vspace{5mm}
    \caption[Overview of notable SGX x86 instructions in an enclave's lifecycle.]{Overview of notable SGX x86 instructions in an enclave's lifecycle.~\cite{sgx-prog-reference}}
    \label{table:sgx-instructions}
\end{table}


\subsection{Attestation}
\label{sec:attestation}

\paragraph{} An essential feature of the \textit{trusted computing} model SGX creates is attestation, the process of verifying both the authenticity and integrity of components cryptographically. SGX achieves by creating two hashed values, or \textit{signing identifiers}, per enclave; \texttt{MRENCLAVE} and \texttt{MRSIGNER}.~\cite{Anati2013InnovativeTF,sgx-prov-service}

\paragraph{} \texttt{MRENCLAVE} acts an a unique identifier for the contents of an enclave. It is generated by hashing the instructions and data passed when creating the enclave with \texttt{ECREATE}, \texttt{EADD}, and \texttt{EEXTEND}; the value is finalised and stored in the \textit{SECS} on \texttt{EINIT}. This value depends on the exact content and ordering of the enclave's \textit{EPC} pages. As long as the enclave's source remains the same, so will its \texttt{MRENCLAVE}.

\paragraph{} \texttt{MRSIGNER}, also known as the enclave's \textit{Sealing Identity}, is generated during the enclave build process --- all production enclaves need to be signed using an RSA key provided by the compiling user (the \textit{Sealing Authority}). The public key from this pair is stored in \textit{SIGSTRUCT}, the \textit{Enclave Signature Structure}. During an enclave's launch its signed compile-time \texttt{MRENCLAVE} value (held in \textit{SIGSTRUCT}) is decrypted and crossreferenced with a freshly-computed runtime \texttt{MRENCLAVE} value to detect tampering. \texttt{MRSIGNER} is the same for all enclaves signed by the same \textit{Sealing Authority}.

\paragraph{Local Attestation} Two enclaves resident on the same system are able to attest their identities to each other using their \texttt{MRENCLAVE} and \texttt{MRSIGNER} values; this usually precedes the establishment of a shared secret (using a variant of \textit{Diffie-Hellman} backed by the platform's master SGX key)\footnote{Note for Harri: must check these details.} for confidential communication between them.

\paragraph{Remote Attestation} In addition to attestation between entities on the same platform, the Intel specification also provides a workflow for an enclave to attest its identity to a remote party. The system's \textit{Quoting Enclave} verifies an enclave's local \textit{quote} and creates a digital signature of it using the CPU's permanent hardware SGX private key. Through the use of an \textit{Intel Enhanced Privacy Identifier} (\textit{EPID})~\cite{epid} this process can be carried out anonymously; it relies on information encoded in the CPU during the manufacturing process. The \textit{Provisioning Enclave} assists in this process, especially as production enclaves are required to attest with Intel's provisioning service~\cite{sgx-prov-service} before executing. Remote attestation is not explicitly required in this project's architecture hence will not be covered in any further detail.

\subsection{Sealing}
\label{sec:sealing}
\paragraph{} \textit{Sealing} refers to the encryption of data using a key related to the generating enclave; this key is unique to that enclave on a particular platform. SGX offers two policies for deriving the encryption key based on the platform's \textit{Root Sealing Key} --- relative to the current enclave (\texttt{MRENCLAVE}) or the current enclave's \textit{Sealing Authority} (\texttt{MRSIGNER}). These serve many use cases, including, for example, allowing state to persist through enclave upgrades.

\subsection{SGX Versions}
\label{sec:sgx-versions}
\paragraph{} At the time of writing there are two versions of SGX available, \textit{v1} and \textit{v2} --- the details given here relate to \textit{v1} as this project will be compatible with both. \textit{v2} offers a number of improvements on which this project does not rely, including: (a) dynamic memory management, (b) eased production enclave restrictions (`Flexible Launch Control'), (c) increased PRM size support, and (d) support for virtualisation.


% -------------

\section{Aspects of the \textit{Linux} Kernel}

\paragraph{} Linux needs little introduction. First created in 1991 as an open-source alternative to UNIX, it now powers over 90\% of \textit{the cloud} and 85\% of smartphones. With almost 25,000 contributors to the kernel, it is immensely complex, with numerous interlocking parts. This section shall provide a brief overview of a small subset of them to support the information given in §~\ref{sec:design}.

\subsection{Virtual File System}

\paragraph{} Linux represents almost every component as a file, for example including sockets, terminals, and driver interfaces. The role of providing this abstraction falls to the VFS, the core function of which is as a transparent layer, routing requests to the correct underlying implementation. This virtual interface relies on the following mechanisms.

\paragraph{Superblocks} The \textit{superblock} attached to an entity represents the characteristics and properties of the filesystem in which it sits. The metadata it holds includes: the block size, statistics on available blocks, the size and location of the filesystem inode tables, the disk block map, and block grouping data. An important marker held in the superblock is it's \textit{magic value}; this predefined code\footnote{Defined in \texttt{include/uapi/linux/magic.h}.} indicates the underlying implementation the filesystem belongs to. Examples include \textit{EXT4} (\texttt{EXT4\_SUPER\_MAGIC}), \textit{pseudo terminal devices} (Linux shells, \texttt{DEVPTS\_SUPER\_MAGIC}), or sockets via \textit{SockFS} (\texttt{SOCKFS\_MAGIC}).

\paragraph{Inodes} The \textit{inode} data structure represents information about a single file existing on a file system. All objects, not only files are \textit{backed} by inodes. No pathname is assigned at this level; this is provided at a higher level of abstraction. An inode does however indicate ownership information, access restrictions and content type, and is identified by its \textit{inode number}.

\paragraph{Dentries} Each item in the \textit{direct entry cache} (\textit{dcache}), shortened to \textit{dentry}, represents a connection between an inode and the path it resides at in the VFS. This glue layer is responsible for building the tangible folder structure, and as the name suggests, metadata caching. A \textit{file} consists of a \textit{dentry}-\textit{inode} pair.

\paragraph{File descriptors} Whenever a process opens a file, it is presented with a \textit{file descriptor} by the kernel (via \texttt{open()} or similar). This structure is unique to a process, providing the gateway between the process and the underlying file it describes. All active descriptors can be viewed at \texttt{/proc/<pid>/fd/}; for standard processes \textit{0} globally refers to \textit{stdin}, \textit{1} to \textit{stdout}, and \textit{2} to \textit{stderr}. Reads and writes to a file (or socket, pipe, etc.) are performed on the relevant file descriptor, not the object directly.

\subsubsection{Extended Attributes} 

\paragraph{} Files can have additional, external, key-value pairs attached to them. These attributes, shortened to \textit{xattrs}, are permanent and saved to disk alongside the file's content. Values are optional and may be left empty if the attribute is just a flag, but if a value is specified it must be in the form of a null-terminated string. \textit{xattrs} are namespaced to define different classes of functionality; the \texttt{user} namespace is open to all (e.g. \texttt{user.example\_attribute}), but \texttt{trusted}, \texttt{system}, and \texttt{security} are reserved for specific uses by the kernel --- the \texttt{security} namespace belongs exclusively to LSMs (§~\ref{sec:lsm}).




\subsection{Linux Security Modules}
\label{sec:lsm}

\paragraph{} Linux supports the inclusion of third-party security models in the kernel itself using a unified framework, LSM. This provides developers with \textit{hooks} into kernel functionality at every point a userspace \textit{syscall} is about to access fundamental kernel primitives, such as inodes or task control structures. Each of these hooks can influence to behaviour of the kernel by allowing or denying the operation.

\paragraph{} LSM attaches a \texttt{void*} security field to every instance of kernel primitives, such as \texttt{struct inode}, to allow security implementations to attach additional state to each, tracking them in whatever way is most appropriate. Decisions taken within an LSM affect all aspects of a Linux system; \textit{superuser} privilege cannot override it and every component in the system can be restricted.


\subsubsection{Integrity Measurement Architecture}

\paragraph{} Linux's IMA subsystem is responsible for calculating the hashes of files and programs as they are loaded (\textit{measurement}), verifying them against an allowed list if required (\textit{appraisal}). Its driving purpose is to detect if files have been maliciously altered either remotely or locally; the file's hash is stored as an \textit{xattr} (\texttt{security.ima}). IMA supports many use cases, the majority of which are complementary to the LSM framework, but we shall focus on one here --- EVM.

\paragraph{} The Linux \textit{Extended Verification Module}, \textit{EVM}, hardens IMA by protecting \textit{xattrs} in the \texttt{security} namespace --- this covers both the IMA hash and any labels created by security modules. Two tamper-detection methods are provided:

\begin{enumerate}
    \item The \textit{HMAC-SHA1} hash of the \texttt{security} namespace is stored as \texttt{security.evm} for reference, and
    \item A digital signature of this value is stored alongside using a key that is sealed either using a \textit{TPM}\footnote{Trusted Platform Module.~\cite{tpm}} or passphrase.
\end{enumerate}

\textcolor{red}{Need to reference in the evaluation.}